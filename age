import re
import spacy

# Load spaCy's English model
nlp = spacy.load("en_core_web_sm")

def preprocess_text(text):
    """
    Preprocess text by removing table-like rows and normalizing whitespace.
    """
    cleaned_lines = []
    for line in text.splitlines():
        # Remove lines that appear to be table rows (e.g., lines with many "|" characters)
        if line.count('|') < 2:
            cleaned_lines.append(line)
    cleaned_text = "\n".join(cleaned_lines)
    cleaned_text = re.sub(r'\s+', ' ', cleaned_text)
    return cleaned_text

def valid_context(context_text):
    """
    Returns True if the context is valid:
    - Must include the word 'screening'
    - Must NOT include excluded keywords like 'weight', 'bmi', or 'body'
    """
    context_doc = nlp(context_text)
    tokens = [token.text.lower() for token in context_doc]
    excluded_keywords = ['weight', 'bmi', 'body']
    return ('screening' in tokens) and (not any(word in tokens for word in excluded_keywords))

def extract_age_from_text(text):
    """
    Extracts min and max age from the given text using regex patterns
    and verifies context with spaCy.
    """
    min_age = None
    max_age = None

    # Define regex patterns for different age expressions
    age_patterns = [
        r'(\d+)\s*-\s*(\d+)\s*years?',       # "18-65 years"
        r'(\d+)\s*to\s*(\d+)\s*years?',      # "18 to 65 years"
        r'≥\s*(\d+)\s*and\s*≤\s*(\d+)',      # "≥10 and ≤65"
        r'min\s*(\d+),?\s*max\s*(\d+)',      # "min 18, max 55"
        r'between\s*(\d+)\s*and\s*(\d+)'     # "between 18 and 60"
    ]

    for pattern in age_patterns:
        for match in re.finditer(pattern, text, re.IGNORECASE):
            context_window = text[max(0, match.start()-50): match.end()+50]
            if valid_context(context_window):
                candidate_min = int(match.group(1))
                candidate_max = int(match.group(2))
                if min_age is None or candidate_min < min_age:
                    min_age = candidate_min
                if max_age is None or candidate_max > max_age:
                    max_age = candidate_max

    # Handle cases where only a minimum age is specified
    if min_age is not None and max_age is None:
        single_min_pattern = re.compile(r'≥\s*(\d+)\s*years?', re.IGNORECASE)
        for match in single_min_pattern.finditer(text):
            context_window = text[max(0, match.start()-50): match.end()+50]
            if valid_context(context_window):
                candidate_min = int(match.group(1))
                if min_age is None or candidate_min < min_age:
                    min_age = candidate_min

    return {"Min age": min_age, "Max age": max_age}

def AgeExtractor(file_path):
    """
    Reads the document, preprocesses the text, extracts the Inclusion criteria
    section, and then returns the extracted min and max age.
    """
    with open(file_path, 'r', encoding='utf-8') as file:
        raw_text = file.read()

    processed_text = preprocess_text(raw_text)
    # Extract text under "Inclusion criteria" up to "Exclusion criteria" or the end of file.
    inclusion_match = re.search(r'(?<=Inclusion criteria)(.*?)(?=Exclusion criteria|$)', 
                                  processed_text, re.DOTALL | re.IGNORECASE)
    if not inclusion_match:
        return {"Min age": None, "Max age": None}

    inclusion_text = inclusion_match.group(0)
    return extract_age_from_text(inclusion_text)
